<h1>Вариант №16. Разработка эмулятора для языка оболочки ОС.</h1>

Разработать эмулятор для языка оболочки ОС. Необходимо сделать работу
эмулятора как можно более похожей на работу в командной строке UNIX-подобной ОС.
Этап 1. REPL.

**Общее описание**.

1. Минимальный прототип эмулятора для языка оболочки ОС. Приложение реализовано в форме консольного приложения. 
2. Предложение к вводу формируется на основе реальных данных ОС, в которой исполняется эмулятор (по типу username@hostname:~$). 
3. Реализован простой парсер, который разделяет ввод на команду и аргументы по пробелам с учётом возможных ошибок (неизвестная команда, неверные аргументы). 
4. Команды представляют собой заглушки, выводящие своё имя и аргументы: ls, cd. Также реализована команда для выхода из эмулятора exit.

<strong>Примеры использования</strong>.
<img width="1062" height="201" alt="image" src="https://github.com/user-attachments/assets/9ccad710-6845-486a-88a9-94ac37c3e741" />





















Этап 2. Конфигурация
Цель: сделать эмулятор настраиваемым, то есть поддержать ввод параметров
пользователя в приложение. Организовать для этого этапа отладочный вывод всех
заданных параметров при запуске эмулятора.
Требования:
1. Параметры командной строки:
– Путь к физическому расположению VFS.
– Путь к стартовому скрипту.
– Путь к конфигурационному файлу.
2. Конфигурационный файл в формате TOML содержит:
– Путь к физическому расположению VFS.
– Путь к стартовому скрипту.
3. Приложение считывает параметры из командной строки и
конфигурационного файла.
4. Логика приоритетов: значения из командной строки имеют приоритет над
значениями из файла.
5. Сообщить об ошибке чтения конфигурационного файла.
6. Стартовый скрипт для выполнения команд эмулятора: останавливается при
первой ошибке. При выполнении скрипта на экране отображается как ввод,
так и вывод, имитируя диалог с пользователем.
7. Сообщить об ошибке во время исполнения стартового скрипта.
8. Реализовать вывод параметров эмулятора в формате ключ-значение с
помощью служебной команды conf-dump.
9. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор.
Включить в каждый скрипт вызовы эмулятора для тестирования всех
поддерживаемых параметров командной строки.
10. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.

Этап 3. VFS
Цель: подключить виртуальную файловую систему (VFS).
Требования:
1. Все операции должны производиться в памяти. Запрещается распаковывать
или иным образом модифицировать данные VFS, за исключением
возможных служебных команд.
2. Источником VFS является JSON-файл. Для двоичных данных используется
base64 или аналогичный формат.
3. Создать несколько скриптов реальной ОС, в которой выполняется эмулятор.
Включить в каждый скрипт вызовы эмулятора для тестирования работы c
различными вариантами VFS (минимальный, несколько файлов, не менее 3
уровней файлов и папок).
4. Создать стартовый скрипт для тестирования всех реализованных на этом и
прошлых этапах команд. Добавить туда примеры всех режимов команд,
включая работу с VFS и обработку ошибок.
5. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.
Этап 4. Основные команды

Цель: поддержать команды, имитирующие работу в UNIX-подобной
командной строке.
Требования:
1. Необходимо реализовать логику для ls и cd.
2. Реализовать новые команды: rev, uname.
3. Создать стартовый скрипт для тестирования всех реализованных на этом
этапе команд. Добавить туда примеры всех режимов команд, включая
работу с VFS и обработку ошибок.
4. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.
Этап 5. Дополнительные команды
Цель: поддержать более сложные команды, изменяющие состояние VFS, при
этом модификации должны осуществляться только в памяти.
Требования:
1. Реализовать команды: rm.
2. Создать стартовый скрипт для тестирования всех реализованных на этом
этапе команд. Добавить туда примеры всех режимов команд, включая
работу с VFS и обработку ошибок.
3. Результат выполнения этапа сохранить в репозиторий стандартно
оформленным коммитом.
